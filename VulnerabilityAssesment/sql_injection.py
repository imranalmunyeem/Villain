import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin
import logging
import random
import os
import concurrent.futures
from requests.auth import HTTPBasicAuth
import validators
import datetime

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class Scanner:
    def __init__(self, user_agents=None):
        self.session = requests.Session()
        self.user_agents = user_agents or [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36",
        ]
        self.rotate_user_agent()

    def rotate_user_agent(self):
        self.session.headers["User-Agent"] = random.choice(self.user_agents)

    def is_valid_url(self, url):
        return validators.url(url)

    def get_forms(self, url):
        try:
            response = self.session.get(url)
            response.raise_for_status()
            soup = BeautifulSoup(response.content, "html.parser")
            return soup.find_all("form")
        except requests.exceptions.RequestException as e:
            logger.error(f"Error getting forms from {url}: {e}")
            return []

    def form_details(self, form):
        details_of_form = {}
        try:
            action = form.attrs.get("action")
            method = form.attrs.get("method", "get")
            inputs = []

            for input_tag in form.find_all("input"):
                input_type = input_tag.attrs.get("type", "text")
                input_name = input_tag.attrs.get("name")
                input_value = input_tag.attrs.get("value", "")
                inputs.append({
                    "type": input_type,
                    "name": input_name,
                    "value": input_value,
                })

            details_of_form['action'] = action
            details_of_form['method'] = method
            details_of_form['inputs'] = inputs
        except Exception as e:
            logger.error(f"Error extracting form details: {e}")
            details_of_form = {}

        return details_of_form

    def vulnerable(self, response):
        errors = {"quoted string not properly terminated",
                  "unclosed quotation mark after the character string",
                  "you have an error in your SQL syntax"
                 }
        for error in errors:
            if error in response.content.decode().lower():
                return True
        return False

    def sql_injection_scan(self, url, custom_payloads=None):
        forms = self.get_forms(url)
        logger.info(f"[+] Detected {len(forms)} forms on {url}.")

        vulnerabilities_found = []

        for form in forms:
            details = self.form_details(form)

            for injection_payload in custom_payloads or self.load_custom_payloads():
                data = {}
                for input_tag in details["inputs"]:
                    if input_tag["type"] == "hidden" or input_tag["value"]:
                        data[input_tag['name']] = input_tag["value"] + injection_payload
                    elif input_tag["type"] != "submit":
                        data[input_tag['name']] = f"test{injection_payload}"

                res = None

                try:
                    self.rotate_user_agent()
                    if details["method"] == "post":
                        res = self.session.post(urljoin(url, details['action']), data=data, timeout=10)
                    elif details["method"] == "get":
                        res = self.session.get(urljoin(url, details['action']), params=data, timeout=10)
                except requests.exceptions.RequestException as e:
                    logger.error(f"Error during HTTP request: {e}")

                if res is not None and self.vulnerable(res):
                    vulnerabilities_found.append({
                        'url': url,
                        'form_details': details,
                        'payload_used': injection_payload
                    })

        return vulnerabilities_found

    def load_custom_payloads(self, file_path):
        custom_payloads = []
        try:
            with open(file_path, 'r') as file:
                custom_payloads = [line.strip() for line in file.readlines() if line.strip()]
        except Exception as e:
            logger.error(f"Error loading custom payloads from file: {e}")

        return custom_payloads

    def generate_report(self, vulnerabilities, report_filename):
        try:
            with open(report_filename, 'w') as report_file:
                report_file.write("<html>\n<head>\n<title>SQL Injection Report</title>\n</head>\n<body>\n")
                report_file.write("<h1>SQL Injection Report</h1>\n")
                report_file.write("<ul>\n")

                for vulnerability in vulnerabilities:
                    report_file.write("<li>\n")
                    report_file.write(f"<strong>URL:</strong> {vulnerability['url']}<br>\n")
                    report_file.write(f"<strong>Form Details:</strong> {vulnerability['form_details']}<br>\n")
                    report_file.write(f"<strong>Payload Used:</strong> {vulnerability['payload_used']}<br>\n")
                    report_file.write("</li>\n")

                report_file.write("</ul>\n</body>\n</html>")
                logger.info(f"Report generated successfully: {report_filename}")
        except Exception as e:
            logger.error(f"Error generating report: {e}")

if __name__ == "__main__":
    scanner = Scanner()

    while True:
        url_to_check = input("Enter the URL to check for SQL injection vulnerabilities: ")
        if scanner.is_valid_url(url_to_check):
            break
        else:
            logger.error("Invalid URL. Please enter a valid URL.")

    custom_payloads_file = input("Enter the absolute path to the custom payloads file: ")

    # Ensure that the provided path is an absolute path
    custom_payloads_file = os.path.abspath(custom_payloads_file)

    custom_payloads = scanner.load_custom_payloads(custom_payloads_file)

    print("\nScanning in progress...")

    # Multithreading for faster scanning
    vulnerabilities_found = []
    with concurrent.futures.ThreadPoolExecutor() as executor:
        vulnerabilities_found = executor.map(scanner.sql_injection_scan, [url_to_check], [custom_payloads])

    vulnerabilities = [vulnerability for vulnerabilities in vulnerabilities_found for vulnerability in vulnerabilities if vulnerabilities]

    if vulnerabilities:
        generate_report = input("Vulnerabilities found! Do you want to generate a report? (yes/no): ").lower()
        if generate_report == 'yes':
            current_date = datetime.datetime.now().strftime("%d%b%Y")
            report_filename = f"sql_injection_report_{current_date}.html"
            scanner.generate_report(vulnerabilities, report_filename)
            print(f"Report generated: {report_filename}")
    else:
        print("No vulnerabilities found.")

    print("Scan completed.")
